<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title></title>
  <meta content="" name="description">
  <meta content="" name="keywords">
  <link href="/static/img/favicon.png" rel="icon">
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,600,600i,700,700i|Raleway:300,300i,400,400i,500,500i,600,600i,700,700i|Poppins:300,300i,400,400i,500,500i,600,600i,700,700i" rel="stylesheet">
  <link href="/static/assets/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href="/static/assets/bootstrap-icons/bootstrap-icons.css" rel="stylesheet">
  <link href="/static/assets/boxicons/css/boxicons.min.css" rel="stylesheet">
  <link href="/static/assets/glightbox/css/glightbox.min.css" rel="stylesheet">
  <link href="/static/assets/remixicon/remixicon.css" rel="stylesheet">
  <link href="/static/assets/swiper/swiper-bundle.min.css" rel="stylesheet">
  <script src="https://kit.fontawesome.com/69e2443572.js" crossorigin="anonymous"></script>
  <link href="/static/css/style.css" rel="stylesheet">
  
</head>
<body>
  <main id="main">

<style>
body::before {
	background: #040404 url("/static/img/portfolio/post.jpg");
}
</style>
    <!-- ======= шаблон для карточки портфолио ======= -->
    <div id="portfolio-details" class="portfolio-details">
      <div class="container">
        <div class="row">
          <div class="col-lg-8">
            <h2 class="portfolio-title">Курсовой проект «Конвертер в текстовую графику»</h2>
          </div>
          <div class="col-lg-8 portfolio-info">
            <h3></h3>
            <ul>
              <li><strong>Категория</strong>: Учебный Проект</li>
              <li><strong>Описание</strong>: Наша цель - разработать класс поискового движка, который способен быстро находить указанное слово среди pdf-файлов, причём ранжировать результаты по количеству вхождений. Также у нас будет сервер, который обслуживает входящие запросы с помощью этого движка.</li>
              <li><strong>Примечания</strong>: <a href="https://github.com/igorivanovo/converterTextGraf.git">Репозиаторий на GitHab</a></li>
            </ul>
            <p>
              <h1>«Конвертер в текстовую графику»</h1>
<p>Нас пригласили поучаствовать в разработке приложения, умеющего скачивать картинки по URL и конвертировать изображения в
текстовую графику (т. е. в текст из разных символов, которые в совокупности выглядят как изображение). Вот пример его
работы. Картинка на нём — это текст из мелких символов:</p>
<p><img src="/static/img/preview.png"  alt="" width="600"></p>
<h2>Структура проекта</h2>
<p><br></p>
<table>
<thead>
<tr>
      <th> Класс / Интерфейс </th>
      <th>Для чего</th>
</tr> 
</thead> 
<tbody>   
<tr>
<td><span style="color:red;">BadImageSizeException </span></td>
<td>Класс исключения, которое мы выбрасываем</td>
</tr>
<tr>
<td><span style="color:red;">TextColorSchema</span></td>
<td>Интерфейс цветовой схемы, который    мы реализуем</td>
</tr>
<tr>
<td><span style="color:red;">TextGraphicsConverter </span></td>
<td>Интерфейс конвертера картинок, который мы реализуем</td>
</tr>
<tr>
<td><span style="color:red;">GServer </span></td>
<td>Класс сервера, который будет использует наш конвертер</td>
</tr>
<tr>
<td><span style="color:red;">Main </span></td>
<td>Запуск приложения. В нём запускается сервер, также в нём можно будет конвертировать картинки в текстовые файлы без сервера</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<h2>Требования к конвертеру</h2>
<p>Самый главный метод — это метод <code>convert</code>, который принимает параметром URL в виде текста, например, <code>«https://raw.githubusercontent.com/netology-code/java-diplom/main/pics/simple-test.png»</code>, внутри метода качает и анализирует картинку, после чего отдаёт значение типа <code>String</code>, в котором содержится это изображение в виде текстовой графики.</p>
<p>В Java <code>String</code> — это текст и не обязательно всего одна строчка текста. Т. е. в один объект типа <code>String</code> можно занести многострочный текст,
а разделителем строк (по сути Enter) будет специальный символ, который пишется в коде как <code>\n</code>. В итоге у вас в конце каждой строчки текстового изображения будет символ переноса строки (запись в коде — <code>\n</code>).</p>
<p>Пример работы конвертера, результат которого выводим в консоль:</p>
<p><code>String url = "https://raw.githubusercontent.com/netology-code/java-diplom/main/pics/simple-test.png";</code><br>
 <code>String imgTxt = converter.convert(url);</code><br>
 <code>System.out.println(imgTxt);</code><br></p>
<p>В итоге мы видим такой результат, где более тёмные участки заменяются на более жирные символы, а светлые на более незаметные символы:
<img src="/static/img/simple-test-demo.jpeg"  alt="" width="600"></p>
<p>Также интерфейс конвертера требует от него возможность выставлять ему настройки перед конвертацией:</p>
<ul>
<li>максимально допустимое соотношение сторон (ширины и высоты). Если метод не вызывали, то любое соотношение допустимо;</li>
<li>максимально допустимую высоту итогового изображения. Если метод не вызывали, то любая высота допустима;</li>
<li>максимально допустимую ширину итогового изображения. Если метод не вызывали, то любая ширина допустима;</li>
<li>текстовую цветовую схему — объект специального интерфейса, который будет отвечать за превращение степени белого (числа от 0 до 255) в символ. Если метод не вызывали, должен использоваться объект написанного вами класса как значение по умолчанию.</li>
</ul>
<p>Например, следующий конвертер не должен конвертировать, если ширина больше длины в три раза, т. к. максимальное соотношение сторон ему выставлено в 2:</p>
<p><code>TextGraphicsConverter converter = ...;</code>// Создайте тут объект нашего класса конвертера<br>
<code>converter.setMaxRatio(2);</code> // выставляет максимально допустимое соотрношение сторон картинки<br>
<code>String imgTxt = converter.convert(...);</code>// для слишком широкой картинки должно выброситься исключение BadImageSizeException.<br></p>
<p>Когда вы передадите конвертер серверу, он выставит ему свои желаемые параметры, которые будут влиять на конвертацию:</p>
<p><img src="/static\img\convert.png"  alt=""></p>
<p>При этом при реализации конвертера информацию об этих конкретных числах мы не используем. Наш конвертер может уметь работать с любыми настройками, описанными выше. Т. е. если в сервере поменяют настройки конвертеру, наш конвертер без изменений кода должен работать с новыми значениями.</p>
<p>Общая схема работы метода <code>convert</code> будет соответствовать последовательности действий (подробнее описаны ниже):</p>
<ol>
<li>Скачиваем картинку по URL.</li>
<li>Менеджеру могли выставить максимально допустимое соотношение сторон (ширины и высоты); если оно слишком большое, то конвертация не делается и выбрасывается исключение.</li>
<li>При конвертации мы будем менять каждый пиксель на символ: чем пиксель темнее, тем жирнее символ, который мы подставим. Менеджеру могли выставить максимальные ширину и высоту итоговой картинки, при этом если исходная картинка больше, то нам надо уменьшить её размер, соблюдая пропорции.</li>
<li>Превращаем цветное изображение в чёрно-белое, чтобы мы смотрели только на интенсивность цвета, а не подбирали для красного одни символы, для зелёного другие и т. п.</li>
<li>Перебираем все пиксели изображения, спрашивая у них степень белого (число от 0 до 255, где 0 — это чёрный, а 255 — это светлый). В зависимости от этого числа выбираем символ из заранее подготовленного набора.</li>
<li>Собираем все полученные символы в единую строку, отдаём как результат конвертации.</li>
</ol>
<p>Костяк метода <code>convert</code>:</p>
<p><code>@Override</code><br>
<code>public String convert(String url) throws IOException,BadImageSizeException {</code><br>
// Вот так просто мы скачаем картинку из интернета :<br>
&ensp;<code>BufferedImage img = ImageIO.read(new URL(url));</code><br>
// Если конвертер попросили проверять на максимально допустимое<br>
// соотношение сторон изображения, то делаем эту проверку,<br>
// и, если картинка не подходит, выбросить исключение BadImageSizeException.<br>
// Чтобы получить ширину картинки, вызываем img.getWidth(), высоту - img.getHeight()<br></p>
<p>// Если конвертеру выставили максимально допустимые ширину и/или высоту,<br>
//  по текущим высоте и ширине вычисляем новые высоту и ширину.<br>
// Соблюдение пропорций означает, что мы должны уменьшать ширину и высоту<br>
// в одинаковое количество раз.<br>
// Пример 1: макс. допустимые 100x100, а картинка 500x200. Новый размер<br>
// будет 100x40 (в 5 раз меньше).<br>
// Пример 2: макс. допустимые 100x30, а картинка 150x15. Новый размер<br>
// будет 100x10 (в 1.5 раза меньше)<br>
// Теперь нам нужно попросить картинку изменить свои размеры на новые.<br>
// Последний параметр означает, что мы просим картинку плавно сузиться<br>
// на новые размеры. В результате мы получаем ссылку на новую картинку, которая<br>
// представляет собой суженную старую.<br>
&ensp;<code>Image scaledImage = img.getScaledInstance(newWidth, newHeight, BufferedImage.SCALE_SMOOT)</code><br>
// Теперь сделаем её чёрно-белой. Для этого :<br>
// Создадим новую пустую картинку нужных размеров, заранее указав последним<br>
// параметром чёрно-белую цветовую палитру:<br>
&ensp;<code>BufferedImage bwImg = new BufferedImage(newWidth, newHeight, BufferedImage.TYPE_BYTE_GRAY);</code><br>
// Попросим у этой картинки инструмент для рисования на ней:<br>
&ensp;<code>Graphics2D graphics = bwImg.createGraphics();</code><br>
// А этому инструменту скажем, чтобы он скопировал содержимое из нашей суженной картинки:<br>
&ensp;<code>graphics.drawImage(scaledImage, 0, 0, null);</code><br></p>
<p>// Теперь в bwImg у нас лежит чёрно-белая картинка нужных нам размеров.<br>
// Мы можете отслеживать каждый из этапов, в любом удобном для<br>
// вас моменте сохранив промежуточную картинку в файл через:<br>
// ImageIO.write(imageObject, "png", new File("out.png"));<br>
// После вызова этой инструкции у нас в проекте появится файл картинки out.<br>
// Теперь  пройдёмся по пикселям нашего изображения.<br>
// Если для рисования мы просили у картинки .createGraphics(),<br>
// то для прохода по пикселям нам нужен будет этот инструмент:<br>
&ensp;<code>WritableRaster bwRaster = bwImg.getRaster;</code><br>
// Он хорош тем, что у него мы можем спросить пиксель на нужных<br>
// нам координатах, указав номер столбца (w) и строки (h)<br>
// int color = bwRaster.getPixel(w, h, new int[3])[0];<br>
// Выглядит странно? Согласен. Сам возвращаемый методом пиксель — это <br>
// массив из трёх интов, обычно это интенсивность красного, зелёного и синего.<br>
// Но у нашей чёрно-белой картинки цветов нет, и нас интересует<br>
// только первое значение в массиве. Ещё мы параметром передаём интовый массив на три ячейки.<br>
// Дело в том, что этот метод не хочет создавать его сам и просит<br>
// нас сделать это, а сам метод лишь заполнит его и вернёт.<br>
// Потому что создавать массивы каждый раз слишком медленно. Мы можем создать<br>
// массив один раз, сохранить в переменную и передавать один<br>
// и тот же массив в метод, ускорив тем самым програм<br>
//  Осталось пробежаться двойным циклом по всем столбцам (ширина)<br>
// и строкам (высота) изображения, на каждой внутренней итерации<br>
// получить степень белого пикселя (int color выше) и по ней<br>
// получить соответствующий символ c. Логикой превращения цвета<br>
// в символ будет заниматься другой объект<br>
<code>for ??? {</code><br>
  &ensp;<code>for ??? {</code><br>
  &ensp;<code>int color = bwRaster.getPixel(w, h, new int[3])[0];</code><br>
  &ensp;<code>char c = schema.convert(color);</code> <br>
  &ensp;<code>???</code> //запоминаем символ c<br>
  &ensp;<code>}</code><br>
<code>}</code><br></p>
<p>// Осталось собрать все символы в один большой текст.<br>
// Для того, чтобы изображение не было слишком узким, <br>
// каждый пиксель превращаем в два повторяющихся символа, полученных<br>
// от схемы<br>
// Возвращаем собранный текст.<br>
<code>}</code><br></p>
<h2>Требования к цветовой схеме</h2>
<p>Мы написали интерфейс конвертера так, чтобы сам он не подбирал каждому цвету определённый <br>символ, но чтобы им занимался другой объект следующего интерфейса:<br></p>
<p><code>public interface TextColorSchema {</code><br>
   &ensp; <code>char convert(int color);</code><br>
<code>}</code><br></p>
            </p>
          </div>
        </div>
      </div>
    </div><!-- конец карточки -->
  <!-- конец поста -->

  </main>
  <!-- Скрипты -->
  <script src="/static/assets/purecounter/purecounter.js"></script>
  <script src="/static/assets/bootstrap/js/bootstrap.bundle.min.js"></script>
  <script src="/static/assets/glightbox/js/glightbox.min.js"></script>
  <script src="/static/assets/isotope-layout/isotope.pkgd.min.js"></script>
  <script src="/static/assets/swiper/swiper-bundle.min.js"></script>
  <script src="/static/assets/waypoints/noframework.waypoints.js"></script>
  <script src="/static/js/main.js"></script>
</body>
</html>